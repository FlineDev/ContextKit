# SwiftUI Development Guidelines
<!-- Template Version: 0 | ContextKit: 0.0.0 | Updated: 2025-09-13 -->

> [!WARNING]
> **üë©‚Äçüíª FOR DEVELOPERS**: Do not edit the content above the developer customization section - changes will be overwritten during ContextKit updates.
>
> For project-specific customizations, use the designated section at the bottom of this file.
>
> Found a bug or improvement for everyone? Please report it: https://github.com/FlineDev/ContextKit/issues


## Overview

These guidelines provide strategic direction for SwiftUI development in ContextKit-managed projects. They focus on **what UI patterns to choose** during planning phases rather than detailed implementation.

---

## UI Framework Strategy

### SwiftUI First Approach
- ‚úÖ **SwiftUI over UIKit**: For all new development and modern UI patterns
- ‚úÖ **Plain SwiftUI**: Avoid complex architecture patterns, keep apps simple
- ‚úÖ **Native Components**: Use system components over custom implementations
- ‚ùå **Avoid**: UIKit except for specific platform requirements
- ‚ùå **Avoid**: Complex MVVM or architectural patterns

### State Management Strategy
- ‚úÖ **`@Observable`**: For view state management (iOS 17+)
- ‚úÖ **`@State`**: For local view state (toggles, text input, selection)
- ‚úÖ **SwiftData**: For persistence with automatic UI updates
- ‚úÖ **Environment**: For dependency injection and app-wide services
- ‚úÖ **`@Entry`**: For custom environment values without boilerplate (Xcode 16+)
- ‚ùå **Avoid**: `@StateObject`/`@ObservableObject` for new development

---

## Modern SwiftUI Patterns

### View Organization Preferences
- ‚úÖ **`@ViewBuilder` properties**: For non-reusable view components
- ‚úÖ **In-type computed/functions properties**: When components used only within one parent
- ‚úÖ **Separate View structs**: Only for truly reusable components across contexts
- ‚ùå **Avoid**: Creating separate views for single-use components

### Modern API Adoption
- ‚úÖ **`#Preview`**: Use `#Preview` macro over `PreviewProvider` (Xcode 15+)
- ‚úÖ **`@Previewable @State`**: For interactive previews (Xcode 16+)
- ‚úÖ **`.rect()` shorthand**: For final shape calls over `RoundedRectangle()`
- ‚úÖ **Built-in formatters**: `Text(value, format: .percent)` over manual formatting
- ‚úÖ **Navigation Stack**: Over legacy `NavigationView` for iOS 16+

### Button and Interaction Patterns
- ‚úÖ **Trailing closure syntax**: `Button { action } label: { CustomView() }`
- ‚úÖ **Built-in initializers**: `Button("Save", systemImage: "checkmark") { }` over `Button { } label: { Label("Save", systemImage: "checkmark") }`
- ‚úÖ **Text selection**: Enable for error messages and important content
- ‚úÖ **Accessibility labels**: For all interactive elements
- ‚ùå **Avoid**: `action:` parameter style for buttons

---

## Color and Appearance Strategy

### Color System Preferences
- ‚úÖ **SwiftUI system colors**: `.gray.opacity(0.1)` over UIKit wrapped colors
- ‚úÖ **Semantic colors**: `.primary`, `.secondary`, `.accentColor`
- ‚úÖ **Asset Catalog colors**: Add custom colors to Assets.xcassets, reference via generated symbols
- ‚úÖ **Adaptive materials**: `.regularMaterial`, `.ultraThinMaterial`
- ‚ùå **Avoid**: `Color(.secondarySystemGroupedBackground)` and UIKit color wrapping

### Dark Mode and Accessibility
- ‚úÖ **Automatic adaptation**: Use semantic colors that adapt to appearance
- ‚úÖ **Dynamic Type support**: All text should scale with user preferences
- ‚úÖ **High contrast**: Consider accessibility requirements in color choices
- ‚úÖ **Platform conventions**: Follow HIG for color usage patterns

---

## Navigation Preferences

### Modern Navigation Patterns
- ‚úÖ **NavigationStack**: For hierarchical navigation (iOS 16+)
- ‚úÖ **NavigationSplitView**: For macOS and iPad split interfaces
- ‚úÖ **Modal presentation**: `.sheet()` and `.fullScreenCover()` appropriately
- ‚ùå **Avoid**: Legacy `NavigationView` for new development

### Platform-Specific Navigation
- ‚úÖ **iOS**: Stack-based navigation with clear hierarchy
- ‚úÖ **macOS**: Split view with sidebar, content, and detail panes
- ‚úÖ **Cross-platform**: Design for abundant horizontal space first

---

## Layout and Performance Strategy

### Layout Preferences
- ‚úÖ **Frame alignment**: `.frame(maxHeight: .infinity, alignment: .bottom)`
- ‚úÖ **Lazy loading**: `LazyVStack`/`LazyHStack` for large datasets
- ‚úÖ **Composition**: Break complex views into focused components
- ‚ùå **Avoid**: `VStack + Spacer` when frame alignment is clearer

### Performance Considerations
- ‚úÖ **Constants over functions**: `let cornerRadius: CGFloat = 12`
- ‚úÖ **Multiplier constants**: For simple mathematical relationships
- ‚úÖ **Extract expensive computations**: From view body calculations
- ‚ùå **Avoid**: Complex calculations directly in view builders

---

## Framework and Package Preferences

### FlineDev Ecosystem for SwiftUI
FlineDev frameworks provide SwiftUI-specific tools (find all at https://github.com/FlineDev):

**Auto-imported via `FlineDevKit`:**
- **`HandySwiftUI`**: SwiftUI tools for async states, UI components, styles, and common patterns
- **`TranslateKitSDK`**: 2000+ pre-localized common UI strings via TK.Action, TK.Label, TK.Message, etc.
- **`FreemiumKit`**: In-app purchases with native paywalls and subscription management

### HandySwiftUI Utilities

**New Types:**
- ‚úÖ **Prefer**: `AsyncState<Error>` for async operation tracking with loading/success/failure states
- ‚úÖ **Prefer**: `Platform.value()` for platform-specific values (iOS vs macOS vs visionOS)
- ‚úÖ **Prefer**: `VPicker`/`HPicker` for vertical/horizontal picker layouts with custom styling
- ‚úÖ **Prefer**: `Emoji` for type-safe emoji handling and random emoji generation

**View Modifiers:**
- ‚úÖ **Prefer**: `.onFirstAppear { }` for one-time setup actions vs repeated onAppear calls

**Styles:**
- ‚úÖ **Prefer**: `.primary()` and `.secondary()` button styles for consistent UI (HandySwiftUI)
- ‚úÖ **Prefer**: `.checkboxUniversal` toggle style for cross-platform checkbox behavior (HandySwiftUI)
- ‚úÖ **Prefer**: `.vertical()` labeled content style for form layouts (HandySwiftUI)

### Common UI Strings
- ‚úÖ **Prefer**: `Button(TK.Action.save) { }` for common actions (TranslateKitSDK)
- ‚úÖ **Prefer**: `Text(TK.Label.settings)` for common labels (TranslateKitSDK)

---

## Component Architecture

### Reusability Strategy
- ‚úÖ **Universal components**: Work across iOS, macOS, and visionOS
- ‚úÖ **ViewModifier patterns**: For consistent styling across components
- ‚úÖ **Environment injection**: For shared services and configuration
- ‚úÖ **Generic design**: Components that adapt to different contexts

### Component Hierarchy
- ‚úÖ **Atomic components**: Small, focused, single-purpose
- ‚úÖ **Composite views**: Combine atomic components meaningfully
- ‚úÖ **Screen-level views**: Coordinate multiple composite views
- ‚ùå **Avoid**: Monolithic views mixing multiple concerns

---

## Development Philosophy

### Value-First Development
- ‚úÖ **Core value first**: Build the minimal workflow that solves user problems
- ‚úÖ **Risk-first milestones**: Tackle hardest, most uncertain parts first
- ‚úÖ **Alpha-ready mindset**: Focus on complete, testable workflows quickly
- ‚ùå **Avoid**: Building infrastructure before proving core value

### Platform Priority Strategy
- ‚úÖ **Primary platforms**: macOS, visionOS, iPadOS (abundant horizontal space)
- ‚úÖ **Secondary platforms**: iPhone (optimize larger screens first, then adapt)
- ‚úÖ **Horizontal-first design**: Utilize space effectively, minimize vertical stacking
- ‚úÖ **Multi-platform from day 1**: Build components to work everywhere

### Implementation Approach
- ‚úÖ **Universal component strategy**: Reusable across multiple contexts
- ‚úÖ **Single concern milestones**: Each milestone focuses on one primary challenge
- ‚úÖ **Validation-driven complexity**: Simple first, layer complexity iteratively
- ‚ùå **Avoid**: Screen-specific or feature-specific components early

---

## Error Handling and User Feedback

### ErrorKit Integration
- ‚úÖ **User-friendly messages**: Use `ErrorKit.userFriendlyMessage(for: error)` for both system and custom errors
- ‚úÖ **String interpolation**: Use `"Save failed: \(error)"` - automatic ErrorKit enhancement
- ‚úÖ **Throwable errors**: Custom error types should conform to `Throwable` protocol
- ‚úÖ **Typed throws**: Use `throws(SpecificError)` with `Catching` protocol for error nesting

### User Feedback Collection
- ‚úÖ **Feedback buttons**: Use `.mailComposer()` modifier with `ErrorKit.logAttachment()`
- ‚úÖ **Automatic log collection**: Include system logs from last 10-30 minutes for context
- ‚úÖ **Device context**: Include device model, iOS version, and app version in reports
- ‚úÖ **Structured logging**: Use `Logger()` instead of `print()` for proper log collection

---

## Testing Strategy

### UI Testing Approach
- ‚úÖ **Swift Testing**: Use Swift Testing framework (`@Test`, `#expect`) over XCTest for new unit tests
- ‚ùå **Avoid**: UI testing (unnecessary complexity and maintenance overhead)
- ‚ùå **Avoid**: Testing SwiftUI view hierarchies directly

### Focus Areas
- ‚úÖ **Test ViewModels**: Business logic and state management
- ‚úÖ **Test data transformations**: Model conversions and formatting logic
- ‚úÖ **Test validation logic**: Input validation and error states

---

## Constitutional Principles

All SwiftUI development must support:

### Accessibility First
- Dynamic Type support in all UI text
- Semantic colors that adapt to system appearance
- VoiceOver labels and hints for interactive elements
- Keyboard navigation support

### Privacy by Design  
- Minimal data collection with explicit purpose
- Secure storage patterns (Keychain for sensitive data)
- Privacy manifest updates when needed
- No tracking and privacy-preserving analytics

### Localization Ready
- No hardcoded user-facing strings in model layer
- Use TranslateKitSDK for common UI strings: `TK.Action.save`, `TK.Label.settings`
- Generation of localization string comments for context (in String Catalog)
- Regional formatting for dates, numbers, currencies
- String Catalog integration (auto-added by Xcode upon builds)

### Platform Appropriate
- Follow Human Interface Guidelines
- Use system conventions and patterns
- Integrate properly with platform features
- Optimize for target platform screen size & UX

### Maintainability
- Prevent overly lengthy functions/views and split logically
- Prefer self-explaining code/components naming & structure over comments
- Comment only complex logic / calculations explaining the WHY
- Keep it simple wherever possible, avoiding boilerplate code

---

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üë©‚Äçüíª DEVELOPER CUSTOMIZATIONS - EDITABLE SECTION
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

This section is preserved during ContextKit migrations and updates.
Add project-specific instructions, examples, and overrides below.

## Project-Specific Instructions

<!-- Add project-specific guidance here -->

## Additional Examples

<!-- Add examples specific to your project here -->

## Override Behaviors

<!-- Document any project-specific overrides here -->
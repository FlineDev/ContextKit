#!/bin/bash
# Template Version: 7 | ContextKit: 0.2.0 | Updated: 2025-12-16

# Custom Claude Code statusline:
# Format: Chat: ████░░░░░░ 44% (87k/200k) | 5h-Usage: 61% (2.3h left)
# With colored progress bar for chat context
#
# Usage: CustomStatusline.sh --plan Pro|Max5|Max20
# Plan parameter is required for accurate cost tracking

# ⚠️ FOR DEVELOPERS: Do not edit this file - changes will be overwritten during ContextKit updates.
# Report bugs: https://github.com/FlineDev/ContextKit/issues

# Read stdin JSON from Claude Code
input=$(cat)

# Color definitions
YELLOW='\033[33m'       # Normal yellow
RED='\033[31m'          # Bright red
LIGHT_GRAY='\033[37m'   # Light gray text
RESET='\033[0m'

# Cache file location
WINDOW_CACHE="$HOME/.claude/statusline-window.json"

# Helper function: Floor timestamp to nearest hour (UTC)
# Input: ISO 8601 timestamp (e.g., "2025-12-16T09:45:30Z")
# Output: ISO 8601 timestamp floored to hour (e.g., "2025-12-16T09:00:00Z")
floor_to_hour() {
    local timestamp="$1"
    # Extract date and hour, set minutes/seconds to 00
    echo "${timestamp:0:14}00:00Z"
}

# Helper function: Detect 5h window start from transcript
# Reads transcript JSONL, finds first user message, floors to hour
# Returns: ISO 8601 timestamp of window start
detect_window_start() {
    local transcript_path="$1"

    if [[ ! -f "$transcript_path" ]]; then
        return 1
    fi

    # Find first user message timestamp
    local first_msg=$(jq -r 'select(.type == "user") | .timestamp' "$transcript_path" 2>/dev/null | head -1)

    if [[ -z "$first_msg" ]]; then
        return 1
    fi

    # Floor to nearest hour
    floor_to_hour "$first_msg"
}

# Helper function: Read and validate window cache
# Returns: 0 if valid cache exists, 1 otherwise
# Sets: WINDOW_START, WINDOW_END, TIME_REMAINING (in seconds)
read_window_cache() {
    if [[ ! -f "$WINDOW_CACHE" ]]; then
        return 1
    fi

    local window_end=$(jq -r '.windowEnd' "$WINDOW_CACHE" 2>/dev/null)
    if [[ -z "$window_end" || "$window_end" == "null" ]]; then
        return 1
    fi

    # Check if window is still valid
    local now_ts=$(date -u +%s)
    local end_ts=$(date -u -j -f "%Y-%m-%dT%H:%M:%SZ" "$window_end" +%s 2>/dev/null)

    if [[ -z "$end_ts" ]] || [[ $now_ts -ge $end_ts ]]; then
        # Window expired
        return 1
    fi

    # Valid cache - export values
    WINDOW_START=$(jq -r '.windowStart' "$WINDOW_CACHE")
    WINDOW_END="$window_end"
    TIME_REMAINING=$((end_ts - now_ts))
    return 0
}

# Helper function: Write window cache (atomic)
# Args: $1=windowStart, $2=windowEnd
write_window_cache() {
    local window_start="$1"
    local window_end="$2"

    # Atomic write using temp file
    echo "{\"windowStart\":\"$window_start\",\"windowEnd\":\"$window_end\"}" > "$WINDOW_CACHE.tmp"
    mv "$WINDOW_CACHE.tmp" "$WINDOW_CACHE"
}

# Parse command line arguments
PLAN=""  # No default - must be specified

while [[ $# -gt 0 ]]; do
    case $1 in
        --plan)
            PLAN="$2"
            shift 2
            ;;
        --help|-h)
            echo "Usage: $0 --plan Pro|Max5|Max20"
            echo "Plan is required for accurate cost tracking"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Usage: $0 --plan Pro|Max5|Max20"
            exit 1
            ;;
    esac
done

# Validate that plan was provided
if [[ -z "$PLAN" ]]; then
    echo "Error: --plan parameter is required"
    echo "Usage: $0 --plan Pro|Max5|Max20"
    exit 1
fi

# Set block budget based on plan
case "$PLAN" in
    "Pro")
        BLOCK_BUDGET="10.00"
        ;;
    "Max20")
        BLOCK_BUDGET="200.00"
        ;;
    "Max5")
        BLOCK_BUDGET="50.00"
        ;;
    *)
        echo "Invalid plan: $PLAN. Use Pro, Max5, or Max20"
        exit 1
        ;;
esac

# Allow environment variable override
BLOCK_BUDGET=${CLAUDE_BLOCK_BUDGET:-$BLOCK_BUDGET}

# Function to create colored progress bar and return color
create_progress_bar() {
    local percent=$1
    local width=10
    local filled=$((percent * width / 100))
    local empty=$((width - filled))

    # Choose color based on percentage
    local color
    if [[ $percent -lt 50 ]]; then
        color="$LIGHT_GRAY"
    elif [[ $percent -lt 80 ]]; then
        color="$YELLOW"
    else
        color="$RED"
    fi

    local bar=""

    # Add filled and empty portions
    for ((i=0; i<filled; i++)); do
        bar+="▓"
    done
    for ((i=0; i<empty; i++)); do
        bar+="░"
    done

    # Return both bar and color (separated by |)
    echo "${color}${bar}|${color}"
}

# Extract context window data from stdin JSON
CONTEXT_SIZE=$(echo "$input" | jq -r '.context_window.context_window_size // 200000')
CURRENT_USAGE=$(echo "$input" | jq '.context_window.current_usage')

# Calculate current context usage from current_usage fields
if [[ "$CURRENT_USAGE" != "null" && -n "$CURRENT_USAGE" ]]; then
    # Current tokens = input + cache_creation + cache_read
    # (output tokens are not included in context window calculation)
    CURRENT_TOKENS=$(echo "$CURRENT_USAGE" | jq '.input_tokens + .cache_creation_input_tokens + .cache_read_input_tokens')
    context_percent=$((CURRENT_TOKENS * 100 / CONTEXT_SIZE))

    # Convert to k format for display
    tokens_k=$(((CURRENT_TOKENS + 999) / 1000))
    context_size_k=$((CONTEXT_SIZE / 1000))
else
    # Fallback if current_usage not available yet
    context_percent=0
    tokens_k=0
    context_size_k=200
fi

# Detect 5h billing window (Phase 1: Custom implementation replacing ccusage)
# Try to read from cache first (fast path)
if read_window_cache; then
    # Cache hit! Use cached window
    total_minutes_left=$((TIME_REMAINING / 60))
else
    # Cache miss - detect window from transcript
    TRANSCRIPT_PATH=$(echo "$input" | jq -r '.transcript_path // empty' 2>/dev/null)

    if [[ -n "$TRANSCRIPT_PATH" ]] && [[ -f "$TRANSCRIPT_PATH" ]]; then
        WINDOW_START=$(detect_window_start "$TRANSCRIPT_PATH")

        if [[ -n "$WINDOW_START" ]]; then
            # Calculate window end: start + 5 hours
            start_ts=$(date -u -j -f "%Y-%m-%dT%H:%M:%SZ" "$WINDOW_START" +%s 2>/dev/null)
            end_ts=$((start_ts + 18000))  # +5 hours (18000 seconds)
            WINDOW_END=$(date -u -j -f "%s" "$end_ts" "+%Y-%m-%dT%H:%M:%SZ" 2>/dev/null)

            # Write to cache (atomic)
            write_window_cache "$WINDOW_START" "$WINDOW_END"

            # Calculate time remaining
            now_ts=$(date -u +%s)
            TIME_REMAINING=$((end_ts - now_ts))
            total_minutes_left=$((TIME_REMAINING / 60))
        fi
    fi
fi

# Format 5h-Usage display
if [[ -n "$WINDOW_START" && -n "$TIME_REMAINING" && $TIME_REMAINING -gt 0 ]]; then
    # TODO Phase 2: Replace hardcoded 0% with actual cost tracking
    window_percent=0  # Placeholder until Phase 2

    # Format time display: minutes if < 60, decimal hours if >= 60
    if [[ $total_minutes_left -lt 60 ]]; then
        time_display="${total_minutes_left}m left"
    else
        # Convert to decimal hours with 1 decimal place
        hours_decimal=$(echo "scale=1; $total_minutes_left / 60" | bc)
        time_display="${hours_decimal}h left"
    fi
    window_info="5h-Usage: ${window_percent}% (${time_display})"
else
    # No window detected - show fallback
    window_info="5h-Usage: N/A (awaiting usage)"
fi

# Format chat context with progress bar using built-in current_usage data
if [[ "$CURRENT_USAGE" != "null" && -n "$CURRENT_USAGE" ]]; then
    # Create colored progress bar
    progress_result=$(create_progress_bar $context_percent)
    progress_bar=$(echo "$progress_result" | cut -d'|' -f1)
    text_color=$(echo "$progress_result" | cut -d'|' -f2)

    context_info="Chat: ${progress_bar} ${text_color}${context_percent}% (${tokens_k}k/${context_size_k}k)${LIGHT_GRAY}"
else
    context_info="Chat: N/A (awaiting usage)"
fi

# Output statusline
echo -e "${LIGHT_GRAY}$context_info | $window_info${RESET}"